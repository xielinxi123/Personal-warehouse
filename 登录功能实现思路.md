# 用户登录

1. 创建数据库，并建立对应的表，tb_user、tb_tea、tb_stu

2. 编写前台页面Log_Manage.jsp、Log_Tea.jsp、Log_Stu.jsp

   * 用户登录前端js校验（表单验证）
     1. 给登录按钮绑定点击事件
     2. 获取用户姓名和密码的值
     3. 判断两个值是否为空（有一个为空就提示用户）
     4. 如果都不为空，则后端手动提交表单

3. 后端代码实现（分层思想：解耦）

   思路：

   1. 接受客户端的请求（接收用户输入的用户名和密码两个参数）
   2. 参数的非空判断（虽然前端做了非空判断，但是如果在前端是别人写的时候，不要相信前端的非空判断）
      * **如果参数为空**，通过消息模型对象返回用户输入的内容（设置输入状态、设置提示信息、回显数据）
      * 将消息模型对象设置到request作用域中
      * 请求转发跳转到对应登录页面
      * return，避免执行下面的同级代码
   3. 通过用户输入的用户名查询用户对象
   4. 判断用户对象是否在数据库中存在
      * **如果不存在**，通过消息模型对象返回用户输入的内容（设置输入状态、设置提示信息、回显数据）
      * 将消息模型对象设置到request作用域中
      * 请求转发跳转到对应的登录页面
      * return，避免执行下面的同级代码
   5. 将数据库中查询到的用户名和密码与用户输入的用户名和密码作比较
      * **如果不相等**，通过消息模型对象返回用户输入的内容（设置输入状态、设置提示信息、回显数据）
      * 将消息模型对象设置到request作用域中
      * 请求转发跳转到对应的登录页面（这里不用return，下面只有一个同级代码了，执行了也无所谓，更何况不会执行）
      * **如果相等**，则表示登录成功，<font color="red">**将用户信息设置到session作用域中，重定向跳转到对应首页**</font>
   6. 各层任务
      * controller层
        1. 接收客户端的请求（接收参数:姓名、密码）
        2. 调用service层的方法，返回消息模型对象
        3. 将消息模型对象设置到request作用域中
        4. 请求转发跳转到登录页面
      * service层
        1. 参数的非空判断
           * 如果参数为空，将状态码、提示信息、回显数据设置到模型对象中，返回消息模型对象
        2. 调用mapper层的查询方法，通过用户名查询用户对象
        3. 判断用户对象是否存在
           * 如果不存在，将状态码、提示信息、回显数据设置到模型对象中，返回消息模型对象
        4. 将成功状态、提示信息、用户对象设置消息模型对象，并return
      * mapper层
        1. 定义对应的接口

   

   # 分层思想

   * contorller层
     * 接受请求
     * 调用service层，返回结果
     * 向前端响应结果
   * service层
     * 业务逻辑判断
     * 在这一层写方法
   * mapper层（Dao层）
     * 接口层
     * mapper.xml（mybatis与数据库的相关操作）
   * entity（也叫做po、moudel）
     * JavaBean实体
   * util
     * 工具类（通用的方法/类）
   * test
     * 测试类/方法